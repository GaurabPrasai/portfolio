"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/notion-to-md";
exports.ids = ["vendor-chunks/notion-to-md"];
exports.modules = {

/***/ "(rsc)/./node_modules/notion-to-md/build/index.js":
/*!**************************************************!*\
  !*** ./node_modules/notion-to-md/build/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./notion-to-md */ \"(rsc)/./node_modules/notion-to-md/build/notion-to-md.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm90aW9uLXRvLW1kL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQywrRUFBZ0I7QUFDckMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvbm90aW9uLXRvLW1kL2J1aWxkL2luZGV4LmpzP2Q0MmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ub3Rpb24tdG8tbWRcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/notion-to-md/build/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/notion-to-md/build/notion-to-md.js":
/*!*********************************************************!*\
  !*** ./node_modules/notion-to-md/build/notion-to-md.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NotionToMarkdown = void 0;\nconst md = __importStar(__webpack_require__(/*! ./utils/md */ \"(rsc)/./node_modules/notion-to-md/build/utils/md.js\"));\nconst notion_1 = __webpack_require__(/*! ./utils/notion */ \"(rsc)/./node_modules/notion-to-md/build/utils/notion.js\");\n/**\n * Converts a Notion page to Markdown.\n */\nclass NotionToMarkdown {\n    constructor(options) {\n        this.notionClient = options.notionClient;\n        const defaultConfig = {\n            separateChildPage: false,\n            convertImagesToBase64: false,\n            parseChildPages: true,\n        };\n        this.config = { ...defaultConfig, ...options.config };\n        this.customTransformers = {};\n    }\n    setCustomTransformer(type, transformer) {\n        this.customTransformers[type] = transformer;\n        return this;\n    }\n    /**\n     * Converts Markdown Blocks to string\n     * @param {MdBlock[]} mdBlocks - Array of markdown blocks\n     * @param {number} nestingLevel - Defines max depth of nesting\n     * @returns {MdStringObject} - Returns markdown string with child pages separated\n     */\n    toMarkdownString(mdBlocks = [], pageIdentifier = \"parent\", nestingLevel = 0) {\n        let mdOutput = {};\n        mdBlocks.forEach((mdBlocks) => {\n            // NOTE: toggle in the child blocks logic\n            // adding a toggle check prevents duplicate\n            // rendering of toggle title\n            var _a;\n            // process parent blocks\n            if (mdBlocks.parent &&\n                mdBlocks.type !== \"toggle\" &&\n                mdBlocks.type !== \"child_page\") {\n                if (mdBlocks.type !== \"to_do\" &&\n                    mdBlocks.type !== \"bulleted_list_item\" &&\n                    mdBlocks.type !== \"numbered_list_item\" &&\n                    mdBlocks.type !== \"quote\") {\n                    // initialize if key doesn't exist\n                    mdOutput[pageIdentifier] = mdOutput[pageIdentifier] || \"\";\n                    // add extra line breaks non list blocks\n                    mdOutput[pageIdentifier] += `\\n${md.addTabSpace(mdBlocks.parent, nestingLevel)}\\n\\n`;\n                }\n                else {\n                    // initialize if key doesn't exist\n                    mdOutput[pageIdentifier] = mdOutput[pageIdentifier] || \"\";\n                    mdOutput[pageIdentifier] += `${md.addTabSpace(mdBlocks.parent, nestingLevel)}\\n`;\n                }\n            }\n            // process child blocks\n            if (mdBlocks.children && mdBlocks.children.length > 0) {\n                if (mdBlocks.type === \"synced_block\" ||\n                    mdBlocks.type === \"column_list\" ||\n                    mdBlocks.type === \"column\") {\n                    let mdstr = this.toMarkdownString(mdBlocks.children, pageIdentifier);\n                    mdOutput[pageIdentifier] = mdOutput[pageIdentifier] || \"\";\n                    Object.keys(mdstr).forEach((key) => {\n                        if (mdOutput[key]) {\n                            mdOutput[key] += mdstr[key];\n                        }\n                        else {\n                            mdOutput[key] = mdstr[key];\n                        }\n                    });\n                }\n                else if (mdBlocks.type === \"child_page\") {\n                    const childPageTitle = mdBlocks.parent;\n                    let mdstr = this.toMarkdownString(mdBlocks.children, childPageTitle);\n                    if (this.config.separateChildPage) {\n                        mdOutput = { ...mdOutput, ...mdstr };\n                    }\n                    else {\n                        mdOutput[pageIdentifier] = mdOutput[pageIdentifier] || \"\";\n                        if (mdstr[childPageTitle]) {\n                            // child page heading followed by child page content\n                            mdOutput[pageIdentifier] +=\n                                `\\n${childPageTitle}\\n${mdstr[childPageTitle]}`;\n                        }\n                    }\n                }\n                else if (mdBlocks.type === \"toggle\") {\n                    // convert children md object to md string\n                    const toggle_children_md_string = this.toMarkdownString(mdBlocks.children);\n                    mdOutput[pageIdentifier] = mdOutput[pageIdentifier] || \"\";\n                    mdOutput[pageIdentifier] += md.toggle(mdBlocks.parent, toggle_children_md_string[\"parent\"]);\n                }\n                else if (mdBlocks.type === \"quote\") {\n                    let mdstr = this.toMarkdownString(mdBlocks.children, pageIdentifier, nestingLevel);\n                    const formattedContent = ((_a = mdstr.parent) !== null && _a !== void 0 ? _a : mdstr[pageIdentifier])\n                        .split(\"\\n\")\n                        .map((line) => (line.trim() ? `> ${line}` : \">\"))\n                        .join(\"\\n\")\n                        .trim();\n                    mdOutput[pageIdentifier] = mdOutput[pageIdentifier] || \"\";\n                    if (pageIdentifier !== \"parent\" && mdstr[\"parent\"]) {\n                        mdOutput[pageIdentifier] += formattedContent;\n                    }\n                    else if (mdstr[pageIdentifier]) {\n                        mdOutput[pageIdentifier] += formattedContent;\n                    }\n                    mdOutput[pageIdentifier] += \"\\n\";\n                }\n                else if (mdBlocks.type === \"callout\") {\n                    // do nothing the callout block is already processed\n                }\n                else {\n                    let mdstr = this.toMarkdownString(mdBlocks.children, pageIdentifier, nestingLevel + 1);\n                    mdOutput[pageIdentifier] = mdOutput[pageIdentifier] || \"\";\n                    if (pageIdentifier !== \"parent\" && mdstr[\"parent\"]) {\n                        mdOutput[pageIdentifier] += mdstr[\"parent\"];\n                    }\n                    else if (mdstr[pageIdentifier]) {\n                        mdOutput[pageIdentifier] += mdstr[pageIdentifier];\n                    }\n                }\n            }\n        });\n        return mdOutput;\n    }\n    /**\n     * Retrieves Notion Blocks based on ID and converts them to Markdown Blocks\n     * @param {string} id - notion page id (not database id)\n     * @param {number} totalPage - Retrieve block children request number, page_size Maximum = totalPage * 100 (Default=null)\n     * @returns {Promise<MdBlock[]>} - List of markdown blocks\n     */\n    async pageToMarkdown(id, totalPage = null) {\n        if (!this.notionClient) {\n            throw new Error(\"notion client is not provided, for more details check out https://github.com/souvikinator/notion-to-md\");\n        }\n        const blocks = await (0, notion_1.getBlockChildren)(this.notionClient, id, totalPage);\n        const parsedData = await this.blocksToMarkdown(blocks);\n        return parsedData;\n    }\n    /**\n     * Converts list of Notion Blocks to Markdown Blocks\n     * @param {ListBlockChildrenResponseResults | undefined} blocks - List of notion blocks\n     * @param {number} totalPage - Retrieve block children request number, page_size Maximum = totalPage * 100\n     * @param {MdBlock[]} mdBlocks - Array of markdown blocks\n     * @returns {Promise<MdBlock[]>} - Array of markdown blocks with their children\n     */\n    async blocksToMarkdown(blocks, totalPage = null, mdBlocks = []) {\n        var _a, _b;\n        if (!this.notionClient) {\n            throw new Error(\"notion client is not provided, for more details check out https://github.com/souvikinator/notion-to-md\");\n        }\n        if (!blocks)\n            return mdBlocks;\n        for (let i = 0; i < blocks.length; i++) {\n            let block = blocks[i];\n            if (\n            // @ts-ignore\n            block.type === \"unsupported\" ||\n                // @ts-ignore\n                (block.type === \"child_page\" && !this.config.parseChildPages)) {\n                continue;\n            }\n            if (\"has_children\" in block && block.has_children) {\n                const block_id = block.type == \"synced_block\" &&\n                    ((_b = (_a = block.synced_block) === null || _a === void 0 ? void 0 : _a.synced_from) === null || _b === void 0 ? void 0 : _b.block_id)\n                    ? block.synced_block.synced_from.block_id\n                    : block.id;\n                // Get children of this block.\n                let child_blocks = await (0, notion_1.getBlockChildren)(this.notionClient, block_id, totalPage);\n                // Push this block to mdBlocks.\n                mdBlocks.push({\n                    type: block.type,\n                    blockId: block.id,\n                    parent: await this.blockToMarkdown(block),\n                    children: [],\n                });\n                // Recursively call blocksToMarkdown to get children of this block.\n                // check for custom transformer before parsing child\n                if (!(block.type in this.customTransformers) &&\n                    !this.customTransformers[block.type]) {\n                    let l = mdBlocks.length;\n                    await this.blocksToMarkdown(child_blocks, totalPage, mdBlocks[l - 1].children);\n                }\n                continue;\n            }\n            let tmp = await this.blockToMarkdown(block);\n            mdBlocks.push({\n                // @ts-ignore\n                type: block.type,\n                blockId: block.id,\n                parent: tmp,\n                children: [],\n            });\n        }\n        return mdBlocks;\n    }\n    /**\n     * Converts a Notion Block to a Markdown Block\n     * @param {ListBlockChildrenResponseResult} block - single notion block\n     * @returns {string} corresponding markdown string of the passed block\n     */\n    async blockToMarkdown(block) {\n        if (typeof block !== \"object\" || !(\"type\" in block))\n            return \"\";\n        let parsedData = \"\";\n        const { type } = block;\n        if (type in this.customTransformers && !!this.customTransformers[type]) {\n            const customTransformerValue = await this.customTransformers[type](block);\n            if (typeof customTransformerValue === \"string\")\n                return customTransformerValue;\n        }\n        switch (type) {\n            case \"image\":\n                {\n                    let blockContent = block.image;\n                    let image_title = \"image\";\n                    const image_caption_plain = blockContent.caption\n                        .map((item) => item.plain_text)\n                        .join(\"\");\n                    const image_type = blockContent.type;\n                    let link = \"\";\n                    if (image_type === \"external\") {\n                        link = blockContent.external.url;\n                    }\n                    if (image_type === \"file\") {\n                        link = blockContent.file.url;\n                    }\n                    // image caption with high priority\n                    if (image_caption_plain.trim().length > 0) {\n                        image_title = image_caption_plain;\n                    }\n                    else if (image_type === \"file\" || image_type === \"external\") {\n                        const matches = link.match(/[^\\/\\\\&\\?]+\\.\\w{3,4}(?=([\\?&].*$|$))/);\n                        image_title = matches ? matches[0] : image_title;\n                    }\n                    return await md.image(image_title, link, this.config.convertImagesToBase64);\n                }\n                break;\n            case \"divider\": {\n                return md.divider();\n            }\n            case \"equation\": {\n                return md.equation(block.equation.expression);\n            }\n            case \"video\":\n            case \"file\":\n            case \"pdf\":\n                {\n                    let blockContent;\n                    let title = type;\n                    if (type === \"video\")\n                        blockContent = block.video;\n                    if (type === \"file\")\n                        blockContent = block.file;\n                    if (type === \"pdf\")\n                        blockContent = block.pdf;\n                    const caption = blockContent === null || blockContent === void 0 ? void 0 : blockContent.caption.map((item) => item.plain_text).join(\"\");\n                    if (blockContent) {\n                        const file_type = blockContent.type;\n                        let link = \"\";\n                        if (file_type === \"external\")\n                            link = blockContent.external.url;\n                        if (file_type === \"file\")\n                            link = blockContent.file.url;\n                        if (caption && caption.trim().length > 0) {\n                            title = caption;\n                        }\n                        else if (link) {\n                            const matches = link.match(/[^\\/\\\\&\\?]+\\.\\w{3,4}(?=([\\?&].*$|$))/);\n                            title = matches ? matches[0] : type;\n                        }\n                        return md.link(title, link);\n                    }\n                }\n                break;\n            case \"bookmark\":\n            case \"embed\":\n            case \"link_preview\":\n            case \"link_to_page\":\n                {\n                    let blockContent;\n                    let title = type;\n                    if (type === \"bookmark\")\n                        blockContent = block.bookmark;\n                    if (type === \"embed\")\n                        blockContent = block.embed;\n                    if (type === \"link_preview\")\n                        blockContent = block.link_preview;\n                    if (type === \"link_to_page\" &&\n                        block.link_to_page.type === \"page_id\") {\n                        blockContent = {\n                            url: `https://www.notion.so/${block.link_to_page.page_id}`,\n                        };\n                    }\n                    if (blockContent)\n                        return md.link(title, blockContent.url);\n                }\n                break;\n            case \"child_page\":\n                {\n                    if (!this.config.parseChildPages)\n                        return \"\";\n                    let pageTitle = block.child_page.title;\n                    if (this.config.separateChildPage) {\n                        return pageTitle;\n                    }\n                    return md.heading2(pageTitle);\n                }\n                break;\n            case \"child_database\":\n                {\n                    let pageTitle = block.child_database.title || `child_database`;\n                    return pageTitle;\n                }\n                break;\n            case \"table\": {\n                const { id, has_children } = block;\n                let tableArr = [];\n                if (has_children) {\n                    const tableRows = await (0, notion_1.getBlockChildren)(this.notionClient, id, 100);\n                    let rowsPromise = tableRows === null || tableRows === void 0 ? void 0 : tableRows.map(async (row) => {\n                        const { type } = row;\n                        if (type !== 'table_row')\n                            return;\n                        const cells = row.table_row[\"cells\"];\n                        /**\n                         * this is more like a hack since matching the type text was\n                         * difficult. So converting each cell to paragraph type to\n                         * reuse the blockToMarkdown function\n                         */\n                        let cellStringPromise = cells.map(async (cell) => await this.blockToMarkdown({\n                            type: \"paragraph\",\n                            paragraph: { rich_text: cell },\n                        }));\n                        const cellStringArr = await Promise.all(cellStringPromise);\n                        tableArr.push(cellStringArr);\n                    });\n                    await Promise.all(rowsPromise || []);\n                }\n                return md.table(tableArr);\n            }\n            // Rest of the types\n            // \"paragraph\"\n            // \"heading_1\"\n            // \"heading_2\"\n            // \"heading_3\"\n            // \"bulleted_list_item\"\n            // \"numbered_list_item\"\n            // \"quote\"\n            // \"to_do\"\n            // \"template\"\n            // \"synced_block\"\n            // \"child_page\"\n            // \"child_database\"\n            // \"code\"\n            // \"callout\"\n            // \"breadcrumb\"\n            // \"table_of_contents\"\n            // \"link_to_page\"\n            // \"audio\"\n            // \"unsupported\"\n            default: {\n                // In this case typescript is not able to index the types properly, hence ignoring the error\n                // @ts-ignore\n                let blockContent = block[type].text || block[type].rich_text || [];\n                blockContent.map((content) => {\n                    if (content.type === \"equation\") {\n                        parsedData += md.inlineEquation(content.equation.expression);\n                        return;\n                    }\n                    const annotations = content.annotations;\n                    let plain_text = content.plain_text;\n                    plain_text = this.annotatePlainText(plain_text, annotations);\n                    if (content[\"href\"])\n                        plain_text = md.link(plain_text, content[\"href\"]);\n                    parsedData += plain_text;\n                });\n            }\n        }\n        switch (type) {\n            case \"code\":\n                {\n                    const codeContent = block.code.rich_text.map((t) => t.plain_text).join(\"\\n\");\n                    const language = block.code.language || \"plaintext\";\n                    parsedData = md.codeBlock(codeContent, language);\n                }\n                break;\n            case \"heading_1\":\n                {\n                    parsedData = md.heading1(parsedData);\n                }\n                break;\n            case \"heading_2\":\n                {\n                    parsedData = md.heading2(parsedData);\n                }\n                break;\n            case \"heading_3\":\n                {\n                    parsedData = md.heading3(parsedData);\n                }\n                break;\n            case \"quote\":\n                {\n                    parsedData = md.quote(parsedData);\n                }\n                break;\n            case \"callout\":\n                {\n                    const { id, has_children } = block;\n                    let callout_string = \"\";\n                    if (!has_children) {\n                        return md.callout(parsedData, block[type].icon);\n                    }\n                    const callout_children_object = await (0, notion_1.getBlockChildren)(this.notionClient, id, 100);\n                    // // parse children blocks to md object\n                    const callout_children = await this.blocksToMarkdown(callout_children_object);\n                    callout_string += `${parsedData}\\n`;\n                    callout_children.map((child) => {\n                        callout_string += `${child.parent}\\n\\n`;\n                    });\n                    parsedData = md.callout(callout_string.trim(), block[type].icon);\n                }\n                break;\n            case \"bulleted_list_item\":\n                {\n                    parsedData = md.bullet(parsedData);\n                }\n                break;\n            case \"numbered_list_item\":\n                {\n                    parsedData = md.bullet(parsedData, block.numbered_list_item.number);\n                }\n                break;\n            case \"to_do\":\n                {\n                    parsedData = md.todo(parsedData, block.to_do.checked);\n                }\n                break;\n        }\n        return parsedData;\n    }\n    /**\n     * Annoate text using provided annotations\n     * @param {string} text - String to be annotated\n     * @param {Annotations} annotations - Annotation object of a notion block\n     * @returns {string} - Annotated text\n     */\n    annotatePlainText(text, annotations) {\n        // if text is all spaces, don't annotate\n        if (text.match(/^\\s*$/))\n            return text;\n        const leadingSpaceMatch = text.match(/^(\\s*)/);\n        const trailingSpaceMatch = text.match(/(\\s*)$/);\n        const leading_space = leadingSpaceMatch ? leadingSpaceMatch[0] : \"\";\n        const trailing_space = trailingSpaceMatch ? trailingSpaceMatch[0] : \"\";\n        text = text.trim();\n        if (text !== \"\") {\n            if (annotations.code)\n                text = md.inlineCode(text);\n            if (annotations.bold)\n                text = md.bold(text);\n            if (annotations.italic)\n                text = md.italic(text);\n            if (annotations.strikethrough)\n                text = md.strikethrough(text);\n            if (annotations.underline)\n                text = md.underline(text);\n        }\n        return leading_space + text + trailing_space;\n    }\n}\nexports.NotionToMarkdown = NotionToMarkdown;\n//# sourceMappingURL=notion-to-md.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm90aW9uLXRvLW1kL2J1aWxkL25vdGlvbi10by1tZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCO0FBQ3hCLHdCQUF3QixtQkFBTyxDQUFDLHVFQUFZO0FBQzVDLGlCQUFpQixtQkFBTyxDQUFDLCtFQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsOENBQThDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDhDQUE4QztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxlQUFlLElBQUksc0JBQXNCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEtBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOENBQThDO0FBQzdELGVBQWUsUUFBUTtBQUN2QixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUNBQWlDO0FBQ2hELGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLElBQUk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxJQUFJO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDJCQUEyQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaUJBQWlCO0FBQzFELHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0EsNkNBQTZDLGFBQWE7QUFDMUQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxhQUFhO0FBQzVCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL25vdGlvbi10by1tZC9idWlsZC9ub3Rpb24tdG8tbWQuanM/MWYwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ob3Rpb25Ub01hcmtkb3duID0gdm9pZCAwO1xuY29uc3QgbWQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbHMvbWRcIikpO1xuY29uc3Qgbm90aW9uXzEgPSByZXF1aXJlKFwiLi91dGlscy9ub3Rpb25cIik7XG4vKipcbiAqIENvbnZlcnRzIGEgTm90aW9uIHBhZ2UgdG8gTWFya2Rvd24uXG4gKi9cbmNsYXNzIE5vdGlvblRvTWFya2Rvd24ge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5ub3Rpb25DbGllbnQgPSBvcHRpb25zLm5vdGlvbkNsaWVudDtcbiAgICAgICAgY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgICAgICAgIHNlcGFyYXRlQ2hpbGRQYWdlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnZlcnRJbWFnZXNUb0Jhc2U2NDogZmFsc2UsXG4gICAgICAgICAgICBwYXJzZUNoaWxkUGFnZXM6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29uZmlnID0geyAuLi5kZWZhdWx0Q29uZmlnLCAuLi5vcHRpb25zLmNvbmZpZyB9O1xuICAgICAgICB0aGlzLmN1c3RvbVRyYW5zZm9ybWVycyA9IHt9O1xuICAgIH1cbiAgICBzZXRDdXN0b21UcmFuc2Zvcm1lcih0eXBlLCB0cmFuc2Zvcm1lcikge1xuICAgICAgICB0aGlzLmN1c3RvbVRyYW5zZm9ybWVyc1t0eXBlXSA9IHRyYW5zZm9ybWVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgTWFya2Rvd24gQmxvY2tzIHRvIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7TWRCbG9ja1tdfSBtZEJsb2NrcyAtIEFycmF5IG9mIG1hcmtkb3duIGJsb2Nrc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXN0aW5nTGV2ZWwgLSBEZWZpbmVzIG1heCBkZXB0aCBvZiBuZXN0aW5nXG4gICAgICogQHJldHVybnMge01kU3RyaW5nT2JqZWN0fSAtIFJldHVybnMgbWFya2Rvd24gc3RyaW5nIHdpdGggY2hpbGQgcGFnZXMgc2VwYXJhdGVkXG4gICAgICovXG4gICAgdG9NYXJrZG93blN0cmluZyhtZEJsb2NrcyA9IFtdLCBwYWdlSWRlbnRpZmllciA9IFwicGFyZW50XCIsIG5lc3RpbmdMZXZlbCA9IDApIHtcbiAgICAgICAgbGV0IG1kT3V0cHV0ID0ge307XG4gICAgICAgIG1kQmxvY2tzLmZvckVhY2goKG1kQmxvY2tzKSA9PiB7XG4gICAgICAgICAgICAvLyBOT1RFOiB0b2dnbGUgaW4gdGhlIGNoaWxkIGJsb2NrcyBsb2dpY1xuICAgICAgICAgICAgLy8gYWRkaW5nIGEgdG9nZ2xlIGNoZWNrIHByZXZlbnRzIGR1cGxpY2F0ZVxuICAgICAgICAgICAgLy8gcmVuZGVyaW5nIG9mIHRvZ2dsZSB0aXRsZVxuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgLy8gcHJvY2VzcyBwYXJlbnQgYmxvY2tzXG4gICAgICAgICAgICBpZiAobWRCbG9ja3MucGFyZW50ICYmXG4gICAgICAgICAgICAgICAgbWRCbG9ja3MudHlwZSAhPT0gXCJ0b2dnbGVcIiAmJlxuICAgICAgICAgICAgICAgIG1kQmxvY2tzLnR5cGUgIT09IFwiY2hpbGRfcGFnZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1kQmxvY2tzLnR5cGUgIT09IFwidG9fZG9cIiAmJlxuICAgICAgICAgICAgICAgICAgICBtZEJsb2Nrcy50eXBlICE9PSBcImJ1bGxldGVkX2xpc3RfaXRlbVwiICYmXG4gICAgICAgICAgICAgICAgICAgIG1kQmxvY2tzLnR5cGUgIT09IFwibnVtYmVyZWRfbGlzdF9pdGVtXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgbWRCbG9ja3MudHlwZSAhPT0gXCJxdW90ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemUgaWYga2V5IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgICAgICAgICAgbWRPdXRwdXRbcGFnZUlkZW50aWZpZXJdID0gbWRPdXRwdXRbcGFnZUlkZW50aWZpZXJdIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBleHRyYSBsaW5lIGJyZWFrcyBub24gbGlzdCBibG9ja3NcbiAgICAgICAgICAgICAgICAgICAgbWRPdXRwdXRbcGFnZUlkZW50aWZpZXJdICs9IGBcXG4ke21kLmFkZFRhYlNwYWNlKG1kQmxvY2tzLnBhcmVudCwgbmVzdGluZ0xldmVsKX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSBpZiBrZXkgZG9lc24ndCBleGlzdFxuICAgICAgICAgICAgICAgICAgICBtZE91dHB1dFtwYWdlSWRlbnRpZmllcl0gPSBtZE91dHB1dFtwYWdlSWRlbnRpZmllcl0gfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgbWRPdXRwdXRbcGFnZUlkZW50aWZpZXJdICs9IGAke21kLmFkZFRhYlNwYWNlKG1kQmxvY2tzLnBhcmVudCwgbmVzdGluZ0xldmVsKX1cXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByb2Nlc3MgY2hpbGQgYmxvY2tzXG4gICAgICAgICAgICBpZiAobWRCbG9ja3MuY2hpbGRyZW4gJiYgbWRCbG9ja3MuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChtZEJsb2Nrcy50eXBlID09PSBcInN5bmNlZF9ibG9ja1wiIHx8XG4gICAgICAgICAgICAgICAgICAgIG1kQmxvY2tzLnR5cGUgPT09IFwiY29sdW1uX2xpc3RcIiB8fFxuICAgICAgICAgICAgICAgICAgICBtZEJsb2Nrcy50eXBlID09PSBcImNvbHVtblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtZHN0ciA9IHRoaXMudG9NYXJrZG93blN0cmluZyhtZEJsb2Nrcy5jaGlsZHJlbiwgcGFnZUlkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICBtZE91dHB1dFtwYWdlSWRlbnRpZmllcl0gPSBtZE91dHB1dFtwYWdlSWRlbnRpZmllcl0gfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMobWRzdHIpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1kT3V0cHV0W2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZE91dHB1dFtrZXldICs9IG1kc3RyW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZE91dHB1dFtrZXldID0gbWRzdHJba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1kQmxvY2tzLnR5cGUgPT09IFwiY2hpbGRfcGFnZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkUGFnZVRpdGxlID0gbWRCbG9ja3MucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWRzdHIgPSB0aGlzLnRvTWFya2Rvd25TdHJpbmcobWRCbG9ja3MuY2hpbGRyZW4sIGNoaWxkUGFnZVRpdGxlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLnNlcGFyYXRlQ2hpbGRQYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZE91dHB1dCA9IHsgLi4ubWRPdXRwdXQsIC4uLm1kc3RyIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZE91dHB1dFtwYWdlSWRlbnRpZmllcl0gPSBtZE91dHB1dFtwYWdlSWRlbnRpZmllcl0gfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZHN0cltjaGlsZFBhZ2VUaXRsZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGlsZCBwYWdlIGhlYWRpbmcgZm9sbG93ZWQgYnkgY2hpbGQgcGFnZSBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWRPdXRwdXRbcGFnZUlkZW50aWZpZXJdICs9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcXG4ke2NoaWxkUGFnZVRpdGxlfVxcbiR7bWRzdHJbY2hpbGRQYWdlVGl0bGVdfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWRCbG9ja3MudHlwZSA9PT0gXCJ0b2dnbGVcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IGNoaWxkcmVuIG1kIG9iamVjdCB0byBtZCBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9nZ2xlX2NoaWxkcmVuX21kX3N0cmluZyA9IHRoaXMudG9NYXJrZG93blN0cmluZyhtZEJsb2Nrcy5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIG1kT3V0cHV0W3BhZ2VJZGVudGlmaWVyXSA9IG1kT3V0cHV0W3BhZ2VJZGVudGlmaWVyXSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBtZE91dHB1dFtwYWdlSWRlbnRpZmllcl0gKz0gbWQudG9nZ2xlKG1kQmxvY2tzLnBhcmVudCwgdG9nZ2xlX2NoaWxkcmVuX21kX3N0cmluZ1tcInBhcmVudFwiXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1kQmxvY2tzLnR5cGUgPT09IFwicXVvdGVcIikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWRzdHIgPSB0aGlzLnRvTWFya2Rvd25TdHJpbmcobWRCbG9ja3MuY2hpbGRyZW4sIHBhZ2VJZGVudGlmaWVyLCBuZXN0aW5nTGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWRDb250ZW50ID0gKChfYSA9IG1kc3RyLnBhcmVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbWRzdHJbcGFnZUlkZW50aWZpZXJdKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNwbGl0KFwiXFxuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKChsaW5lKSA9PiAobGluZS50cmltKCkgPyBgPiAke2xpbmV9YCA6IFwiPlwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKFwiXFxuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBtZE91dHB1dFtwYWdlSWRlbnRpZmllcl0gPSBtZE91dHB1dFtwYWdlSWRlbnRpZmllcl0gfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhZ2VJZGVudGlmaWVyICE9PSBcInBhcmVudFwiICYmIG1kc3RyW1wicGFyZW50XCJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZE91dHB1dFtwYWdlSWRlbnRpZmllcl0gKz0gZm9ybWF0dGVkQ29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtZHN0cltwYWdlSWRlbnRpZmllcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1kT3V0cHV0W3BhZ2VJZGVudGlmaWVyXSArPSBmb3JtYXR0ZWRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1kT3V0cHV0W3BhZ2VJZGVudGlmaWVyXSArPSBcIlxcblwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZEJsb2Nrcy50eXBlID09PSBcImNhbGxvdXRcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nIHRoZSBjYWxsb3V0IGJsb2NrIGlzIGFscmVhZHkgcHJvY2Vzc2VkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWRzdHIgPSB0aGlzLnRvTWFya2Rvd25TdHJpbmcobWRCbG9ja3MuY2hpbGRyZW4sIHBhZ2VJZGVudGlmaWVyLCBuZXN0aW5nTGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgbWRPdXRwdXRbcGFnZUlkZW50aWZpZXJdID0gbWRPdXRwdXRbcGFnZUlkZW50aWZpZXJdIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWdlSWRlbnRpZmllciAhPT0gXCJwYXJlbnRcIiAmJiBtZHN0cltcInBhcmVudFwiXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWRPdXRwdXRbcGFnZUlkZW50aWZpZXJdICs9IG1kc3RyW1wicGFyZW50XCJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1kc3RyW3BhZ2VJZGVudGlmaWVyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWRPdXRwdXRbcGFnZUlkZW50aWZpZXJdICs9IG1kc3RyW3BhZ2VJZGVudGlmaWVyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZE91dHB1dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIE5vdGlvbiBCbG9ja3MgYmFzZWQgb24gSUQgYW5kIGNvbnZlcnRzIHRoZW0gdG8gTWFya2Rvd24gQmxvY2tzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gbm90aW9uIHBhZ2UgaWQgKG5vdCBkYXRhYmFzZSBpZClcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG90YWxQYWdlIC0gUmV0cmlldmUgYmxvY2sgY2hpbGRyZW4gcmVxdWVzdCBudW1iZXIsIHBhZ2Vfc2l6ZSBNYXhpbXVtID0gdG90YWxQYWdlICogMTAwIChEZWZhdWx0PW51bGwpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TWRCbG9ja1tdPn0gLSBMaXN0IG9mIG1hcmtkb3duIGJsb2Nrc1xuICAgICAqL1xuICAgIGFzeW5jIHBhZ2VUb01hcmtkb3duKGlkLCB0b3RhbFBhZ2UgPSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5ub3Rpb25DbGllbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdGlvbiBjbGllbnQgaXMgbm90IHByb3ZpZGVkLCBmb3IgbW9yZSBkZXRhaWxzIGNoZWNrIG91dCBodHRwczovL2dpdGh1Yi5jb20vc291dmlraW5hdG9yL25vdGlvbi10by1tZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9ja3MgPSBhd2FpdCAoMCwgbm90aW9uXzEuZ2V0QmxvY2tDaGlsZHJlbikodGhpcy5ub3Rpb25DbGllbnQsIGlkLCB0b3RhbFBhZ2UpO1xuICAgICAgICBjb25zdCBwYXJzZWREYXRhID0gYXdhaXQgdGhpcy5ibG9ja3NUb01hcmtkb3duKGJsb2Nrcyk7XG4gICAgICAgIHJldHVybiBwYXJzZWREYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBsaXN0IG9mIE5vdGlvbiBCbG9ja3MgdG8gTWFya2Rvd24gQmxvY2tzXG4gICAgICogQHBhcmFtIHtMaXN0QmxvY2tDaGlsZHJlblJlc3BvbnNlUmVzdWx0cyB8IHVuZGVmaW5lZH0gYmxvY2tzIC0gTGlzdCBvZiBub3Rpb24gYmxvY2tzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsUGFnZSAtIFJldHJpZXZlIGJsb2NrIGNoaWxkcmVuIHJlcXVlc3QgbnVtYmVyLCBwYWdlX3NpemUgTWF4aW11bSA9IHRvdGFsUGFnZSAqIDEwMFxuICAgICAqIEBwYXJhbSB7TWRCbG9ja1tdfSBtZEJsb2NrcyAtIEFycmF5IG9mIG1hcmtkb3duIGJsb2Nrc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1kQmxvY2tbXT59IC0gQXJyYXkgb2YgbWFya2Rvd24gYmxvY2tzIHdpdGggdGhlaXIgY2hpbGRyZW5cbiAgICAgKi9cbiAgICBhc3luYyBibG9ja3NUb01hcmtkb3duKGJsb2NrcywgdG90YWxQYWdlID0gbnVsbCwgbWRCbG9ja3MgPSBbXSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoIXRoaXMubm90aW9uQ2xpZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3Rpb24gY2xpZW50IGlzIG5vdCBwcm92aWRlZCwgZm9yIG1vcmUgZGV0YWlscyBjaGVjayBvdXQgaHR0cHM6Ly9naXRodWIuY29tL3NvdXZpa2luYXRvci9ub3Rpb24tdG8tbWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFibG9ja3MpXG4gICAgICAgICAgICByZXR1cm4gbWRCbG9ja3M7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYmxvY2sgPSBibG9ja3NbaV07XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBibG9jay50eXBlID09PSBcInVuc3VwcG9ydGVkXCIgfHxcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgKGJsb2NrLnR5cGUgPT09IFwiY2hpbGRfcGFnZVwiICYmICF0aGlzLmNvbmZpZy5wYXJzZUNoaWxkUGFnZXMpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJoYXNfY2hpbGRyZW5cIiBpbiBibG9jayAmJiBibG9jay5oYXNfY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBibG9ja19pZCA9IGJsb2NrLnR5cGUgPT0gXCJzeW5jZWRfYmxvY2tcIiAmJlxuICAgICAgICAgICAgICAgICAgICAoKF9iID0gKF9hID0gYmxvY2suc3luY2VkX2Jsb2NrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3luY2VkX2Zyb20pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ibG9ja19pZClcbiAgICAgICAgICAgICAgICAgICAgPyBibG9jay5zeW5jZWRfYmxvY2suc3luY2VkX2Zyb20uYmxvY2tfaWRcbiAgICAgICAgICAgICAgICAgICAgOiBibG9jay5pZDtcbiAgICAgICAgICAgICAgICAvLyBHZXQgY2hpbGRyZW4gb2YgdGhpcyBibG9jay5cbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRfYmxvY2tzID0gYXdhaXQgKDAsIG5vdGlvbl8xLmdldEJsb2NrQ2hpbGRyZW4pKHRoaXMubm90aW9uQ2xpZW50LCBibG9ja19pZCwgdG90YWxQYWdlKTtcbiAgICAgICAgICAgICAgICAvLyBQdXNoIHRoaXMgYmxvY2sgdG8gbWRCbG9ja3MuXG4gICAgICAgICAgICAgICAgbWRCbG9ja3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGJsb2NrLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrSWQ6IGJsb2NrLmlkLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGF3YWl0IHRoaXMuYmxvY2tUb01hcmtkb3duKGJsb2NrKSxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNhbGwgYmxvY2tzVG9NYXJrZG93biB0byBnZXQgY2hpbGRyZW4gb2YgdGhpcyBibG9jay5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgY3VzdG9tIHRyYW5zZm9ybWVyIGJlZm9yZSBwYXJzaW5nIGNoaWxkXG4gICAgICAgICAgICAgICAgaWYgKCEoYmxvY2sudHlwZSBpbiB0aGlzLmN1c3RvbVRyYW5zZm9ybWVycykgJiZcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuY3VzdG9tVHJhbnNmb3JtZXJzW2Jsb2NrLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsID0gbWRCbG9ja3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmJsb2Nrc1RvTWFya2Rvd24oY2hpbGRfYmxvY2tzLCB0b3RhbFBhZ2UsIG1kQmxvY2tzW2wgLSAxXS5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRtcCA9IGF3YWl0IHRoaXMuYmxvY2tUb01hcmtkb3duKGJsb2NrKTtcbiAgICAgICAgICAgIG1kQmxvY2tzLnB1c2goe1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB0eXBlOiBibG9jay50eXBlLFxuICAgICAgICAgICAgICAgIGJsb2NrSWQ6IGJsb2NrLmlkLFxuICAgICAgICAgICAgICAgIHBhcmVudDogdG1wLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZEJsb2NrcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBOb3Rpb24gQmxvY2sgdG8gYSBNYXJrZG93biBCbG9ja1xuICAgICAqIEBwYXJhbSB7TGlzdEJsb2NrQ2hpbGRyZW5SZXNwb25zZVJlc3VsdH0gYmxvY2sgLSBzaW5nbGUgbm90aW9uIGJsb2NrXG4gICAgICogQHJldHVybnMge3N0cmluZ30gY29ycmVzcG9uZGluZyBtYXJrZG93biBzdHJpbmcgb2YgdGhlIHBhc3NlZCBibG9ja1xuICAgICAqL1xuICAgIGFzeW5jIGJsb2NrVG9NYXJrZG93bihibG9jaykge1xuICAgICAgICBpZiAodHlwZW9mIGJsb2NrICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0eXBlXCIgaW4gYmxvY2spKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIGxldCBwYXJzZWREYXRhID0gXCJcIjtcbiAgICAgICAgY29uc3QgeyB0eXBlIH0gPSBibG9jaztcbiAgICAgICAgaWYgKHR5cGUgaW4gdGhpcy5jdXN0b21UcmFuc2Zvcm1lcnMgJiYgISF0aGlzLmN1c3RvbVRyYW5zZm9ybWVyc1t0eXBlXSkge1xuICAgICAgICAgICAgY29uc3QgY3VzdG9tVHJhbnNmb3JtZXJWYWx1ZSA9IGF3YWl0IHRoaXMuY3VzdG9tVHJhbnNmb3JtZXJzW3R5cGVdKGJsb2NrKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VzdG9tVHJhbnNmb3JtZXJWYWx1ZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VzdG9tVHJhbnNmb3JtZXJWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJsb2NrQ29udGVudCA9IGJsb2NrLmltYWdlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW1hZ2VfdGl0bGUgPSBcImltYWdlXCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlX2NhcHRpb25fcGxhaW4gPSBibG9ja0NvbnRlbnQuY2FwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoaXRlbSkgPT4gaXRlbS5wbGFpbl90ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlX3R5cGUgPSBibG9ja0NvbnRlbnQudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmsgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VfdHlwZSA9PT0gXCJleHRlcm5hbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rID0gYmxvY2tDb250ZW50LmV4dGVybmFsLnVybDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VfdHlwZSA9PT0gXCJmaWxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsgPSBibG9ja0NvbnRlbnQuZmlsZS51cmw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaW1hZ2UgY2FwdGlvbiB3aXRoIGhpZ2ggcHJpb3JpdHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlX2NhcHRpb25fcGxhaW4udHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlX3RpdGxlID0gaW1hZ2VfY2FwdGlvbl9wbGFpbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbWFnZV90eXBlID09PSBcImZpbGVcIiB8fCBpbWFnZV90eXBlID09PSBcImV4dGVybmFsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBsaW5rLm1hdGNoKC9bXlxcL1xcXFwmXFw/XStcXC5cXHd7Myw0fSg/PShbXFw/Jl0uKiR8JCkpLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZV90aXRsZSA9IG1hdGNoZXMgPyBtYXRjaGVzWzBdIDogaW1hZ2VfdGl0bGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IG1kLmltYWdlKGltYWdlX3RpdGxlLCBsaW5rLCB0aGlzLmNvbmZpZy5jb252ZXJ0SW1hZ2VzVG9CYXNlNjQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkaXZpZGVyXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWQuZGl2aWRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImVxdWF0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWQuZXF1YXRpb24oYmxvY2suZXF1YXRpb24uZXhwcmVzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidmlkZW9cIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6XG4gICAgICAgICAgICBjYXNlIFwicGRmXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYmxvY2tDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGl0bGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJ2aWRlb1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tDb250ZW50ID0gYmxvY2sudmlkZW87XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImZpbGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrQ29udGVudCA9IGJsb2NrLmZpbGU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcInBkZlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tDb250ZW50ID0gYmxvY2sucGRmO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXB0aW9uID0gYmxvY2tDb250ZW50ID09PSBudWxsIHx8IGJsb2NrQ29udGVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmxvY2tDb250ZW50LmNhcHRpb24ubWFwKChpdGVtKSA9PiBpdGVtLnBsYWluX3RleHQpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChibG9ja0NvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVfdHlwZSA9IGJsb2NrQ29udGVudC50eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmsgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVfdHlwZSA9PT0gXCJleHRlcm5hbFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsgPSBibG9ja0NvbnRlbnQuZXh0ZXJuYWwudXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVfdHlwZSA9PT0gXCJmaWxlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluayA9IGJsb2NrQ29udGVudC5maWxlLnVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXB0aW9uICYmIGNhcHRpb24udHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IGNhcHRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGxpbmsubWF0Y2goL1teXFwvXFxcXCZcXD9dK1xcLlxcd3szLDR9KD89KFtcXD8mXS4qJHwkKSkvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IG1hdGNoZXMgPyBtYXRjaGVzWzBdIDogdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZC5saW5rKHRpdGxlLCBsaW5rKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJib29rbWFya1wiOlxuICAgICAgICAgICAgY2FzZSBcImVtYmVkXCI6XG4gICAgICAgICAgICBjYXNlIFwibGlua19wcmV2aWV3XCI6XG4gICAgICAgICAgICBjYXNlIFwibGlua190b19wYWdlXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYmxvY2tDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGl0bGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJib29rbWFya1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tDb250ZW50ID0gYmxvY2suYm9va21hcms7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImVtYmVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja0NvbnRlbnQgPSBibG9jay5lbWJlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwibGlua19wcmV2aWV3XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja0NvbnRlbnQgPSBibG9jay5saW5rX3ByZXZpZXc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImxpbmtfdG9fcGFnZVwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9jay5saW5rX3RvX3BhZ2UudHlwZSA9PT0gXCJwYWdlX2lkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrQ29udGVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGBodHRwczovL3d3dy5ub3Rpb24uc28vJHtibG9jay5saW5rX3RvX3BhZ2UucGFnZV9pZH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tDb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1kLmxpbmsodGl0bGUsIGJsb2NrQ29udGVudC51cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjaGlsZF9wYWdlXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29uZmlnLnBhcnNlQ2hpbGRQYWdlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFnZVRpdGxlID0gYmxvY2suY2hpbGRfcGFnZS50aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLnNlcGFyYXRlQ2hpbGRQYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFnZVRpdGxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZC5oZWFkaW5nMihwYWdlVGl0bGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjaGlsZF9kYXRhYmFzZVwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhZ2VUaXRsZSA9IGJsb2NrLmNoaWxkX2RhdGFiYXNlLnRpdGxlIHx8IGBjaGlsZF9kYXRhYmFzZWA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWdlVGl0bGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInRhYmxlXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlkLCBoYXNfY2hpbGRyZW4gfSA9IGJsb2NrO1xuICAgICAgICAgICAgICAgIGxldCB0YWJsZUFyciA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChoYXNfY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFibGVSb3dzID0gYXdhaXQgKDAsIG5vdGlvbl8xLmdldEJsb2NrQ2hpbGRyZW4pKHRoaXMubm90aW9uQ2xpZW50LCBpZCwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJvd3NQcm9taXNlID0gdGFibGVSb3dzID09PSBudWxsIHx8IHRhYmxlUm93cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVSb3dzLm1hcChhc3luYyAocm93KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHJvdztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSAndGFibGVfcm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxscyA9IHJvdy50YWJsZV9yb3dbXCJjZWxsc1wiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogdGhpcyBpcyBtb3JlIGxpa2UgYSBoYWNrIHNpbmNlIG1hdGNoaW5nIHRoZSB0eXBlIHRleHQgd2FzXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBkaWZmaWN1bHQuIFNvIGNvbnZlcnRpbmcgZWFjaCBjZWxsIHRvIHBhcmFncmFwaCB0eXBlIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiByZXVzZSB0aGUgYmxvY2tUb01hcmtkb3duIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjZWxsU3RyaW5nUHJvbWlzZSA9IGNlbGxzLm1hcChhc3luYyAoY2VsbCkgPT4gYXdhaXQgdGhpcy5ibG9ja1RvTWFya2Rvd24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicGFyYWdyYXBoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYWdyYXBoOiB7IHJpY2hfdGV4dDogY2VsbCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbFN0cmluZ0FyciA9IGF3YWl0IFByb21pc2UuYWxsKGNlbGxTdHJpbmdQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlQXJyLnB1c2goY2VsbFN0cmluZ0Fycik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChyb3dzUHJvbWlzZSB8fCBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtZC50YWJsZSh0YWJsZUFycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXN0IG9mIHRoZSB0eXBlc1xuICAgICAgICAgICAgLy8gXCJwYXJhZ3JhcGhcIlxuICAgICAgICAgICAgLy8gXCJoZWFkaW5nXzFcIlxuICAgICAgICAgICAgLy8gXCJoZWFkaW5nXzJcIlxuICAgICAgICAgICAgLy8gXCJoZWFkaW5nXzNcIlxuICAgICAgICAgICAgLy8gXCJidWxsZXRlZF9saXN0X2l0ZW1cIlxuICAgICAgICAgICAgLy8gXCJudW1iZXJlZF9saXN0X2l0ZW1cIlxuICAgICAgICAgICAgLy8gXCJxdW90ZVwiXG4gICAgICAgICAgICAvLyBcInRvX2RvXCJcbiAgICAgICAgICAgIC8vIFwidGVtcGxhdGVcIlxuICAgICAgICAgICAgLy8gXCJzeW5jZWRfYmxvY2tcIlxuICAgICAgICAgICAgLy8gXCJjaGlsZF9wYWdlXCJcbiAgICAgICAgICAgIC8vIFwiY2hpbGRfZGF0YWJhc2VcIlxuICAgICAgICAgICAgLy8gXCJjb2RlXCJcbiAgICAgICAgICAgIC8vIFwiY2FsbG91dFwiXG4gICAgICAgICAgICAvLyBcImJyZWFkY3J1bWJcIlxuICAgICAgICAgICAgLy8gXCJ0YWJsZV9vZl9jb250ZW50c1wiXG4gICAgICAgICAgICAvLyBcImxpbmtfdG9fcGFnZVwiXG4gICAgICAgICAgICAvLyBcImF1ZGlvXCJcbiAgICAgICAgICAgIC8vIFwidW5zdXBwb3J0ZWRcIlxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSB0eXBlc2NyaXB0IGlzIG5vdCBhYmxlIHRvIGluZGV4IHRoZSB0eXBlcyBwcm9wZXJseSwgaGVuY2UgaWdub3JpbmcgdGhlIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGxldCBibG9ja0NvbnRlbnQgPSBibG9ja1t0eXBlXS50ZXh0IHx8IGJsb2NrW3R5cGVdLnJpY2hfdGV4dCB8fCBbXTtcbiAgICAgICAgICAgICAgICBibG9ja0NvbnRlbnQubWFwKChjb250ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50LnR5cGUgPT09IFwiZXF1YXRpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0YSArPSBtZC5pbmxpbmVFcXVhdGlvbihjb250ZW50LmVxdWF0aW9uLmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFubm90YXRpb25zID0gY29udGVudC5hbm5vdGF0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBsYWluX3RleHQgPSBjb250ZW50LnBsYWluX3RleHQ7XG4gICAgICAgICAgICAgICAgICAgIHBsYWluX3RleHQgPSB0aGlzLmFubm90YXRlUGxhaW5UZXh0KHBsYWluX3RleHQsIGFubm90YXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRbXCJocmVmXCJdKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhaW5fdGV4dCA9IG1kLmxpbmsocGxhaW5fdGV4dCwgY29udGVudFtcImhyZWZcIl0pO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRhICs9IHBsYWluX3RleHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiY29kZVwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZUNvbnRlbnQgPSBibG9jay5jb2RlLnJpY2hfdGV4dC5tYXAoKHQpID0+IHQucGxhaW5fdGV4dCkuam9pbihcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBibG9jay5jb2RlLmxhbmd1YWdlIHx8IFwicGxhaW50ZXh0XCI7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGEgPSBtZC5jb2RlQmxvY2soY29kZUNvbnRlbnQsIGxhbmd1YWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaGVhZGluZ18xXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRhID0gbWQuaGVhZGluZzEocGFyc2VkRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImhlYWRpbmdfMlwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0YSA9IG1kLmhlYWRpbmcyKHBhcnNlZERhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJoZWFkaW5nXzNcIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGEgPSBtZC5oZWFkaW5nMyhwYXJzZWREYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicXVvdGVcIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGEgPSBtZC5xdW90ZShwYXJzZWREYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2FsbG91dFwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBpZCwgaGFzX2NoaWxkcmVuIH0gPSBibG9jaztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNhbGxvdXRfc3RyaW5nID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNfY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZC5jYWxsb3V0KHBhcnNlZERhdGEsIGJsb2NrW3R5cGVdLmljb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxvdXRfY2hpbGRyZW5fb2JqZWN0ID0gYXdhaXQgKDAsIG5vdGlvbl8xLmdldEJsb2NrQ2hpbGRyZW4pKHRoaXMubm90aW9uQ2xpZW50LCBpZCwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gLy8gcGFyc2UgY2hpbGRyZW4gYmxvY2tzIHRvIG1kIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsb3V0X2NoaWxkcmVuID0gYXdhaXQgdGhpcy5ibG9ja3NUb01hcmtkb3duKGNhbGxvdXRfY2hpbGRyZW5fb2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbG91dF9zdHJpbmcgKz0gYCR7cGFyc2VkRGF0YX1cXG5gO1xuICAgICAgICAgICAgICAgICAgICBjYWxsb3V0X2NoaWxkcmVuLm1hcCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxvdXRfc3RyaW5nICs9IGAke2NoaWxkLnBhcmVudH1cXG5cXG5gO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0YSA9IG1kLmNhbGxvdXQoY2FsbG91dF9zdHJpbmcudHJpbSgpLCBibG9ja1t0eXBlXS5pY29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYnVsbGV0ZWRfbGlzdF9pdGVtXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRhID0gbWQuYnVsbGV0KHBhcnNlZERhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJlZF9saXN0X2l0ZW1cIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGEgPSBtZC5idWxsZXQocGFyc2VkRGF0YSwgYmxvY2subnVtYmVyZWRfbGlzdF9pdGVtLm51bWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInRvX2RvXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRhID0gbWQudG9kbyhwYXJzZWREYXRhLCBibG9jay50b19kby5jaGVja2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZERhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFubm9hdGUgdGV4dCB1c2luZyBwcm92aWRlZCBhbm5vdGF0aW9uc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gU3RyaW5nIHRvIGJlIGFubm90YXRlZFxuICAgICAqIEBwYXJhbSB7QW5ub3RhdGlvbnN9IGFubm90YXRpb25zIC0gQW5ub3RhdGlvbiBvYmplY3Qgb2YgYSBub3Rpb24gYmxvY2tcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIEFubm90YXRlZCB0ZXh0XG4gICAgICovXG4gICAgYW5ub3RhdGVQbGFpblRleHQodGV4dCwgYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgLy8gaWYgdGV4dCBpcyBhbGwgc3BhY2VzLCBkb24ndCBhbm5vdGF0ZVxuICAgICAgICBpZiAodGV4dC5tYXRjaCgvXlxccyokLykpXG4gICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgY29uc3QgbGVhZGluZ1NwYWNlTWF0Y2ggPSB0ZXh0Lm1hdGNoKC9eKFxccyopLyk7XG4gICAgICAgIGNvbnN0IHRyYWlsaW5nU3BhY2VNYXRjaCA9IHRleHQubWF0Y2goLyhcXHMqKSQvKTtcbiAgICAgICAgY29uc3QgbGVhZGluZ19zcGFjZSA9IGxlYWRpbmdTcGFjZU1hdGNoID8gbGVhZGluZ1NwYWNlTWF0Y2hbMF0gOiBcIlwiO1xuICAgICAgICBjb25zdCB0cmFpbGluZ19zcGFjZSA9IHRyYWlsaW5nU3BhY2VNYXRjaCA/IHRyYWlsaW5nU3BhY2VNYXRjaFswXSA6IFwiXCI7XG4gICAgICAgIHRleHQgPSB0ZXh0LnRyaW0oKTtcbiAgICAgICAgaWYgKHRleHQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9ucy5jb2RlKVxuICAgICAgICAgICAgICAgIHRleHQgPSBtZC5pbmxpbmVDb2RlKHRleHQpO1xuICAgICAgICAgICAgaWYgKGFubm90YXRpb25zLmJvbGQpXG4gICAgICAgICAgICAgICAgdGV4dCA9IG1kLmJvbGQodGV4dCk7XG4gICAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMuaXRhbGljKVxuICAgICAgICAgICAgICAgIHRleHQgPSBtZC5pdGFsaWModGV4dCk7XG4gICAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMuc3RyaWtldGhyb3VnaClcbiAgICAgICAgICAgICAgICB0ZXh0ID0gbWQuc3RyaWtldGhyb3VnaCh0ZXh0KTtcbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9ucy51bmRlcmxpbmUpXG4gICAgICAgICAgICAgICAgdGV4dCA9IG1kLnVuZGVybGluZSh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVhZGluZ19zcGFjZSArIHRleHQgKyB0cmFpbGluZ19zcGFjZTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlvblRvTWFya2Rvd24gPSBOb3Rpb25Ub01hcmtkb3duO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm90aW9uLXRvLW1kLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/notion-to-md/build/notion-to-md.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/notion-to-md/build/utils/md.js":
/*!*****************************************************!*\
  !*** ./node_modules/notion-to-md/build/utils/md.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.table = exports.toggle = exports.divider = exports.addTabSpace = exports.image = exports.todo = exports.bullet = exports.callout = exports.quote = exports.heading3 = exports.heading2 = exports.heading1 = exports.equation = exports.codeBlock = exports.link = exports.underline = exports.strikethrough = exports.italic = exports.bold = exports.inlineEquation = exports.inlineCode = void 0;\nconst markdown_table_1 = __importDefault(__webpack_require__(/*! markdown-table */ \"(rsc)/./node_modules/markdown-table/index.js\"));\nconst node_fetch_1 = __importDefault(__webpack_require__(/*! node-fetch */ \"(rsc)/./node_modules/node-fetch/lib/index.mjs\"));\nconst inlineCode = (text) => {\n    return `\\`${text}\\``;\n};\nexports.inlineCode = inlineCode;\nconst inlineEquation = (text) => {\n    return `$${text}$`;\n};\nexports.inlineEquation = inlineEquation;\nconst bold = (text) => {\n    return `**${text}**`;\n};\nexports.bold = bold;\nconst italic = (text) => {\n    return `_${text}_`;\n};\nexports.italic = italic;\nconst strikethrough = (text) => {\n    return `~~${text}~~`;\n};\nexports.strikethrough = strikethrough;\nconst underline = (text) => {\n    return `<u>${text}</u>`;\n};\nexports.underline = underline;\nconst link = (text, href) => {\n    return `[${text}](${href})`;\n};\nexports.link = link;\nconst codeBlock = (text, language) => {\n    if (!text)\n        return \"\";\n    // Ensure a valid language, default to \"plaintext\" if missing\n    const lang = language && language.trim() ? language.toLowerCase() : \"plaintext\";\n    return `\\`\\`\\`${lang}\n${text.trim()}\n\\`\\`\\``;\n};\nexports.codeBlock = codeBlock;\nconst equation = (text) => {\n    return `$$\n${text}\n$$`;\n};\nexports.equation = equation;\nconst heading1 = (text) => {\n    return `# ${text}`;\n};\nexports.heading1 = heading1;\nconst heading2 = (text) => {\n    return `## ${text}`;\n};\nexports.heading2 = heading2;\nconst heading3 = (text) => {\n    return `### ${text}`;\n};\nexports.heading3 = heading3;\nconst quote = (text) => {\n    // the replace is done to handle multiple lines\n    return `> ${text.replace(/\\n/g, \"  \\n> \")}`;\n};\nexports.quote = quote;\nconst callout = (text, icon) => {\n    let emoji;\n    if ((icon === null || icon === void 0 ? void 0 : icon.type) === \"emoji\") {\n        emoji = icon.emoji;\n    }\n    // the replace is done to handle multiple lines\n    const formattedText = text.replace(/\\n/g, \"  \\n> \");\n    const formattedEmoji = emoji ? emoji + \" \" : \"\";\n    const headingMatch = formattedText.match(/^(#{1,6})\\s+([.*\\s\\S]+)/);\n    if (headingMatch) {\n        const headingLevel = headingMatch[1].length;\n        const headingContent = headingMatch[2];\n        return `> ${\"#\".repeat(headingLevel)} ${formattedEmoji}${headingContent}`;\n    }\n    return `> ${formattedEmoji}${formattedText}`;\n};\nexports.callout = callout;\nconst bullet = (text, count) => {\n    let renderText = text.trim();\n    return count ? `${count}. ${renderText}` : `- ${renderText}`;\n};\nexports.bullet = bullet;\nconst todo = (text, checked) => {\n    return checked ? `- [x] ${text}` : `- [ ] ${text}`;\n};\nexports.todo = todo;\nconst image = async (alt, href, convertToBase64 = false) => {\n    // In case the user does not want to convert the images to Base64\n    // or the image is already base64\n    if (!convertToBase64 || href.startsWith(\"data:\")) {\n        if (href.startsWith(\"data:\")) {\n            // Extract base64 data, i.e. the string after 'data:mime/type;base64,'\n            const base64 = href.split(\",\").pop();\n            // This overrides incorrect data: string format to png\n            // so that browsers can correctly render the data\n            return `![${alt}](data:image/png;base64,${base64})`;\n        }\n        return `![${alt}](${href})`;\n    }\n    else {\n        // Otherwise, download the image and convert it to base64\n        const res = await (0, node_fetch_1.default)(href);\n        const buf = await res.arrayBuffer();\n        const base64 = Buffer.from(buf).toString(\"base64\");\n        return `![${alt}](data:image/png;base64,${base64})`;\n    }\n};\nexports.image = image;\nconst addTabSpace = (text, n = 0) => {\n    const tab = \"    \";\n    for (let i = 0; i < n; i++) {\n        if (text.includes(\"\\n\")) {\n            const multiLineText = text.split(/(?:^|\\n)/).join(`\\n${tab}`);\n            text = tab + multiLineText;\n        }\n        else\n            text = tab + text;\n    }\n    return text;\n};\nexports.addTabSpace = addTabSpace;\nconst divider = () => {\n    return \"---\";\n};\nexports.divider = divider;\nconst toggle = (summary, children) => {\n    if (!summary)\n        return children || \"\";\n    return `<details>\n<summary>${summary}</summary>\n${children || \"\"}\n</details>\\n\\n`;\n};\nexports.toggle = toggle;\nconst table = (cells) => {\n    return (0, markdown_table_1.default)(cells);\n};\nexports.table = table;\n//# sourceMappingURL=md.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm90aW9uLXRvLW1kL2J1aWxkL3V0aWxzL21kLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLGNBQWMsR0FBRyxlQUFlLEdBQUcsbUJBQW1CLEdBQUcsYUFBYSxHQUFHLFlBQVksR0FBRyxjQUFjLEdBQUcsZUFBZSxHQUFHLGFBQWEsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxpQkFBaUIsR0FBRyxZQUFZLEdBQUcsaUJBQWlCLEdBQUcscUJBQXFCLEdBQUcsY0FBYyxHQUFHLFlBQVksR0FBRyxzQkFBc0IsR0FBRyxrQkFBa0I7QUFDalkseUNBQXlDLG1CQUFPLENBQUMsb0VBQWdCO0FBQ2pFLHFDQUFxQyxtQkFBTyxDQUFDLGlFQUFZO0FBQ3pEO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQjtBQUNBLFlBQVk7QUFDWjtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBLGNBQWM7QUFDZDtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCLEtBQUs7QUFDdEI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxlQUFlLEtBQUssSUFBSSxLQUFLO0FBQzdCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsRUFBRTtBQUNGO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsS0FBSztBQUN0QjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0IsOEJBQThCO0FBQzlDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsSUFBSTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCLEVBQUUsZUFBZSxFQUFFLGVBQWU7QUFDaEY7QUFDQSxnQkFBZ0IsZUFBZSxFQUFFLGNBQWM7QUFDL0M7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLHNCQUFzQixNQUFNLElBQUksV0FBVyxTQUFTLFdBQVc7QUFDL0Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSw4QkFBOEIsS0FBSyxhQUFhLEtBQUs7QUFDckQ7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsSUFBSSxpQkFBaUIsU0FBUyxPQUFPO0FBQzdEO0FBQ0Esb0JBQW9CLElBQUksSUFBSSxLQUFLO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixJQUFJLGlCQUFpQixTQUFTLE9BQU87QUFDekQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQSxtRUFBbUUsSUFBSTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsRUFBRTtBQUNGO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL25vdGlvbi10by1tZC9idWlsZC91dGlscy9tZC5qcz8yODM2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50YWJsZSA9IGV4cG9ydHMudG9nZ2xlID0gZXhwb3J0cy5kaXZpZGVyID0gZXhwb3J0cy5hZGRUYWJTcGFjZSA9IGV4cG9ydHMuaW1hZ2UgPSBleHBvcnRzLnRvZG8gPSBleHBvcnRzLmJ1bGxldCA9IGV4cG9ydHMuY2FsbG91dCA9IGV4cG9ydHMucXVvdGUgPSBleHBvcnRzLmhlYWRpbmczID0gZXhwb3J0cy5oZWFkaW5nMiA9IGV4cG9ydHMuaGVhZGluZzEgPSBleHBvcnRzLmVxdWF0aW9uID0gZXhwb3J0cy5jb2RlQmxvY2sgPSBleHBvcnRzLmxpbmsgPSBleHBvcnRzLnVuZGVybGluZSA9IGV4cG9ydHMuc3RyaWtldGhyb3VnaCA9IGV4cG9ydHMuaXRhbGljID0gZXhwb3J0cy5ib2xkID0gZXhwb3J0cy5pbmxpbmVFcXVhdGlvbiA9IGV4cG9ydHMuaW5saW5lQ29kZSA9IHZvaWQgMDtcbmNvbnN0IG1hcmtkb3duX3RhYmxlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm1hcmtkb3duLXRhYmxlXCIpKTtcbmNvbnN0IG5vZGVfZmV0Y2hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibm9kZS1mZXRjaFwiKSk7XG5jb25zdCBpbmxpbmVDb2RlID0gKHRleHQpID0+IHtcbiAgICByZXR1cm4gYFxcYCR7dGV4dH1cXGBgO1xufTtcbmV4cG9ydHMuaW5saW5lQ29kZSA9IGlubGluZUNvZGU7XG5jb25zdCBpbmxpbmVFcXVhdGlvbiA9ICh0ZXh0KSA9PiB7XG4gICAgcmV0dXJuIGAkJHt0ZXh0fSRgO1xufTtcbmV4cG9ydHMuaW5saW5lRXF1YXRpb24gPSBpbmxpbmVFcXVhdGlvbjtcbmNvbnN0IGJvbGQgPSAodGV4dCkgPT4ge1xuICAgIHJldHVybiBgKioke3RleHR9KipgO1xufTtcbmV4cG9ydHMuYm9sZCA9IGJvbGQ7XG5jb25zdCBpdGFsaWMgPSAodGV4dCkgPT4ge1xuICAgIHJldHVybiBgXyR7dGV4dH1fYDtcbn07XG5leHBvcnRzLml0YWxpYyA9IGl0YWxpYztcbmNvbnN0IHN0cmlrZXRocm91Z2ggPSAodGV4dCkgPT4ge1xuICAgIHJldHVybiBgfn4ke3RleHR9fn5gO1xufTtcbmV4cG9ydHMuc3RyaWtldGhyb3VnaCA9IHN0cmlrZXRocm91Z2g7XG5jb25zdCB1bmRlcmxpbmUgPSAodGV4dCkgPT4ge1xuICAgIHJldHVybiBgPHU+JHt0ZXh0fTwvdT5gO1xufTtcbmV4cG9ydHMudW5kZXJsaW5lID0gdW5kZXJsaW5lO1xuY29uc3QgbGluayA9ICh0ZXh0LCBocmVmKSA9PiB7XG4gICAgcmV0dXJuIGBbJHt0ZXh0fV0oJHtocmVmfSlgO1xufTtcbmV4cG9ydHMubGluayA9IGxpbms7XG5jb25zdCBjb2RlQmxvY2sgPSAodGV4dCwgbGFuZ3VhZ2UpID0+IHtcbiAgICBpZiAoIXRleHQpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIC8vIEVuc3VyZSBhIHZhbGlkIGxhbmd1YWdlLCBkZWZhdWx0IHRvIFwicGxhaW50ZXh0XCIgaWYgbWlzc2luZ1xuICAgIGNvbnN0IGxhbmcgPSBsYW5ndWFnZSAmJiBsYW5ndWFnZS50cmltKCkgPyBsYW5ndWFnZS50b0xvd2VyQ2FzZSgpIDogXCJwbGFpbnRleHRcIjtcbiAgICByZXR1cm4gYFxcYFxcYFxcYCR7bGFuZ31cbiR7dGV4dC50cmltKCl9XG5cXGBcXGBcXGBgO1xufTtcbmV4cG9ydHMuY29kZUJsb2NrID0gY29kZUJsb2NrO1xuY29uc3QgZXF1YXRpb24gPSAodGV4dCkgPT4ge1xuICAgIHJldHVybiBgJCRcbiR7dGV4dH1cbiQkYDtcbn07XG5leHBvcnRzLmVxdWF0aW9uID0gZXF1YXRpb247XG5jb25zdCBoZWFkaW5nMSA9ICh0ZXh0KSA9PiB7XG4gICAgcmV0dXJuIGAjICR7dGV4dH1gO1xufTtcbmV4cG9ydHMuaGVhZGluZzEgPSBoZWFkaW5nMTtcbmNvbnN0IGhlYWRpbmcyID0gKHRleHQpID0+IHtcbiAgICByZXR1cm4gYCMjICR7dGV4dH1gO1xufTtcbmV4cG9ydHMuaGVhZGluZzIgPSBoZWFkaW5nMjtcbmNvbnN0IGhlYWRpbmczID0gKHRleHQpID0+IHtcbiAgICByZXR1cm4gYCMjIyAke3RleHR9YDtcbn07XG5leHBvcnRzLmhlYWRpbmczID0gaGVhZGluZzM7XG5jb25zdCBxdW90ZSA9ICh0ZXh0KSA9PiB7XG4gICAgLy8gdGhlIHJlcGxhY2UgaXMgZG9uZSB0byBoYW5kbGUgbXVsdGlwbGUgbGluZXNcbiAgICByZXR1cm4gYD4gJHt0ZXh0LnJlcGxhY2UoL1xcbi9nLCBcIiAgXFxuPiBcIil9YDtcbn07XG5leHBvcnRzLnF1b3RlID0gcXVvdGU7XG5jb25zdCBjYWxsb3V0ID0gKHRleHQsIGljb24pID0+IHtcbiAgICBsZXQgZW1vamk7XG4gICAgaWYgKChpY29uID09PSBudWxsIHx8IGljb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGljb24udHlwZSkgPT09IFwiZW1vamlcIikge1xuICAgICAgICBlbW9qaSA9IGljb24uZW1vamk7XG4gICAgfVxuICAgIC8vIHRoZSByZXBsYWNlIGlzIGRvbmUgdG8gaGFuZGxlIG11bHRpcGxlIGxpbmVzXG4gICAgY29uc3QgZm9ybWF0dGVkVGV4dCA9IHRleHQucmVwbGFjZSgvXFxuL2csIFwiICBcXG4+IFwiKTtcbiAgICBjb25zdCBmb3JtYXR0ZWRFbW9qaSA9IGVtb2ppID8gZW1vamkgKyBcIiBcIiA6IFwiXCI7XG4gICAgY29uc3QgaGVhZGluZ01hdGNoID0gZm9ybWF0dGVkVGV4dC5tYXRjaCgvXigjezEsNn0pXFxzKyhbLipcXHNcXFNdKykvKTtcbiAgICBpZiAoaGVhZGluZ01hdGNoKSB7XG4gICAgICAgIGNvbnN0IGhlYWRpbmdMZXZlbCA9IGhlYWRpbmdNYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGhlYWRpbmdDb250ZW50ID0gaGVhZGluZ01hdGNoWzJdO1xuICAgICAgICByZXR1cm4gYD4gJHtcIiNcIi5yZXBlYXQoaGVhZGluZ0xldmVsKX0gJHtmb3JtYXR0ZWRFbW9qaX0ke2hlYWRpbmdDb250ZW50fWA7XG4gICAgfVxuICAgIHJldHVybiBgPiAke2Zvcm1hdHRlZEVtb2ppfSR7Zm9ybWF0dGVkVGV4dH1gO1xufTtcbmV4cG9ydHMuY2FsbG91dCA9IGNhbGxvdXQ7XG5jb25zdCBidWxsZXQgPSAodGV4dCwgY291bnQpID0+IHtcbiAgICBsZXQgcmVuZGVyVGV4dCA9IHRleHQudHJpbSgpO1xuICAgIHJldHVybiBjb3VudCA/IGAke2NvdW50fS4gJHtyZW5kZXJUZXh0fWAgOiBgLSAke3JlbmRlclRleHR9YDtcbn07XG5leHBvcnRzLmJ1bGxldCA9IGJ1bGxldDtcbmNvbnN0IHRvZG8gPSAodGV4dCwgY2hlY2tlZCkgPT4ge1xuICAgIHJldHVybiBjaGVja2VkID8gYC0gW3hdICR7dGV4dH1gIDogYC0gWyBdICR7dGV4dH1gO1xufTtcbmV4cG9ydHMudG9kbyA9IHRvZG87XG5jb25zdCBpbWFnZSA9IGFzeW5jIChhbHQsIGhyZWYsIGNvbnZlcnRUb0Jhc2U2NCA9IGZhbHNlKSA9PiB7XG4gICAgLy8gSW4gY2FzZSB0aGUgdXNlciBkb2VzIG5vdCB3YW50IHRvIGNvbnZlcnQgdGhlIGltYWdlcyB0byBCYXNlNjRcbiAgICAvLyBvciB0aGUgaW1hZ2UgaXMgYWxyZWFkeSBiYXNlNjRcbiAgICBpZiAoIWNvbnZlcnRUb0Jhc2U2NCB8fCBocmVmLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkge1xuICAgICAgICBpZiAoaHJlZi5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgYmFzZTY0IGRhdGEsIGkuZS4gdGhlIHN0cmluZyBhZnRlciAnZGF0YTptaW1lL3R5cGU7YmFzZTY0LCdcbiAgICAgICAgICAgIGNvbnN0IGJhc2U2NCA9IGhyZWYuc3BsaXQoXCIsXCIpLnBvcCgpO1xuICAgICAgICAgICAgLy8gVGhpcyBvdmVycmlkZXMgaW5jb3JyZWN0IGRhdGE6IHN0cmluZyBmb3JtYXQgdG8gcG5nXG4gICAgICAgICAgICAvLyBzbyB0aGF0IGJyb3dzZXJzIGNhbiBjb3JyZWN0bHkgcmVuZGVyIHRoZSBkYXRhXG4gICAgICAgICAgICByZXR1cm4gYCFbJHthbHR9XShkYXRhOmltYWdlL3BuZztiYXNlNjQsJHtiYXNlNjR9KWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAhWyR7YWx0fV0oJHtocmVmfSlgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBkb3dubG9hZCB0aGUgaW1hZ2UgYW5kIGNvbnZlcnQgaXQgdG8gYmFzZTY0XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0ICgwLCBub2RlX2ZldGNoXzEuZGVmYXVsdCkoaHJlZik7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGF3YWl0IHJlcy5hcnJheUJ1ZmZlcigpO1xuICAgICAgICBjb25zdCBiYXNlNjQgPSBCdWZmZXIuZnJvbShidWYpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgICAgICByZXR1cm4gYCFbJHthbHR9XShkYXRhOmltYWdlL3BuZztiYXNlNjQsJHtiYXNlNjR9KWA7XG4gICAgfVxufTtcbmV4cG9ydHMuaW1hZ2UgPSBpbWFnZTtcbmNvbnN0IGFkZFRhYlNwYWNlID0gKHRleHQsIG4gPSAwKSA9PiB7XG4gICAgY29uc3QgdGFiID0gXCIgICAgXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgaWYgKHRleHQuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgICAgICAgIGNvbnN0IG11bHRpTGluZVRleHQgPSB0ZXh0LnNwbGl0KC8oPzpefFxcbikvKS5qb2luKGBcXG4ke3RhYn1gKTtcbiAgICAgICAgICAgIHRleHQgPSB0YWIgKyBtdWx0aUxpbmVUZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRleHQgPSB0YWIgKyB0ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbn07XG5leHBvcnRzLmFkZFRhYlNwYWNlID0gYWRkVGFiU3BhY2U7XG5jb25zdCBkaXZpZGVyID0gKCkgPT4ge1xuICAgIHJldHVybiBcIi0tLVwiO1xufTtcbmV4cG9ydHMuZGl2aWRlciA9IGRpdmlkZXI7XG5jb25zdCB0b2dnbGUgPSAoc3VtbWFyeSwgY2hpbGRyZW4pID0+IHtcbiAgICBpZiAoIXN1bW1hcnkpXG4gICAgICAgIHJldHVybiBjaGlsZHJlbiB8fCBcIlwiO1xuICAgIHJldHVybiBgPGRldGFpbHM+XG48c3VtbWFyeT4ke3N1bW1hcnl9PC9zdW1tYXJ5PlxuJHtjaGlsZHJlbiB8fCBcIlwifVxuPC9kZXRhaWxzPlxcblxcbmA7XG59O1xuZXhwb3J0cy50b2dnbGUgPSB0b2dnbGU7XG5jb25zdCB0YWJsZSA9IChjZWxscykgPT4ge1xuICAgIHJldHVybiAoMCwgbWFya2Rvd25fdGFibGVfMS5kZWZhdWx0KShjZWxscyk7XG59O1xuZXhwb3J0cy50YWJsZSA9IHRhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/notion-to-md/build/utils/md.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/notion-to-md/build/utils/notion.js":
/*!*********************************************************!*\
  !*** ./node_modules/notion-to-md/build/utils/notion.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.modifyNumberedListObject = exports.getBlockChildren = void 0;\nconst getBlockChildren = async (notionClient, block_id, totalPage) => {\n    let result = [];\n    let pageCount = 0;\n    let start_cursor = undefined;\n    do {\n        const response = (await notionClient.blocks.children.list({\n            start_cursor: start_cursor,\n            block_id: block_id,\n        }));\n        result.push(...response.results);\n        start_cursor = response === null || response === void 0 ? void 0 : response.next_cursor;\n        pageCount += 1;\n    } while (start_cursor != null &&\n        (totalPage == null || pageCount < totalPage));\n    (0, exports.modifyNumberedListObject)(result);\n    return result;\n};\nexports.getBlockChildren = getBlockChildren;\nconst modifyNumberedListObject = (blocks) => {\n    let numberedListIndex = 0;\n    for (const block of blocks) {\n        if (\"type\" in block && block.type === \"numbered_list_item\") {\n            // add numbers\n            // @ts-ignore\n            block.numbered_list_item.number = ++numberedListIndex;\n        }\n        else {\n            numberedListIndex = 0;\n        }\n    }\n};\nexports.modifyNumberedListObject = modifyNumberedListObject;\n//# sourceMappingURL=notion.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm90aW9uLXRvLW1kL2J1aWxkL3V0aWxzL25vdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRyx3QkFBd0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvbm90aW9uLXRvLW1kL2J1aWxkL3V0aWxzL25vdGlvbi5qcz8zMmI2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tb2RpZnlOdW1iZXJlZExpc3RPYmplY3QgPSBleHBvcnRzLmdldEJsb2NrQ2hpbGRyZW4gPSB2b2lkIDA7XG5jb25zdCBnZXRCbG9ja0NoaWxkcmVuID0gYXN5bmMgKG5vdGlvbkNsaWVudCwgYmxvY2tfaWQsIHRvdGFsUGFnZSkgPT4ge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBsZXQgcGFnZUNvdW50ID0gMDtcbiAgICBsZXQgc3RhcnRfY3Vyc29yID0gdW5kZWZpbmVkO1xuICAgIGRvIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSAoYXdhaXQgbm90aW9uQ2xpZW50LmJsb2Nrcy5jaGlsZHJlbi5saXN0KHtcbiAgICAgICAgICAgIHN0YXJ0X2N1cnNvcjogc3RhcnRfY3Vyc29yLFxuICAgICAgICAgICAgYmxvY2tfaWQ6IGJsb2NrX2lkLFxuICAgICAgICB9KSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKC4uLnJlc3BvbnNlLnJlc3VsdHMpO1xuICAgICAgICBzdGFydF9jdXJzb3IgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UubmV4dF9jdXJzb3I7XG4gICAgICAgIHBhZ2VDb3VudCArPSAxO1xuICAgIH0gd2hpbGUgKHN0YXJ0X2N1cnNvciAhPSBudWxsICYmXG4gICAgICAgICh0b3RhbFBhZ2UgPT0gbnVsbCB8fCBwYWdlQ291bnQgPCB0b3RhbFBhZ2UpKTtcbiAgICAoMCwgZXhwb3J0cy5tb2RpZnlOdW1iZXJlZExpc3RPYmplY3QpKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLmdldEJsb2NrQ2hpbGRyZW4gPSBnZXRCbG9ja0NoaWxkcmVuO1xuY29uc3QgbW9kaWZ5TnVtYmVyZWRMaXN0T2JqZWN0ID0gKGJsb2NrcykgPT4ge1xuICAgIGxldCBudW1iZXJlZExpc3RJbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBibG9jayBvZiBibG9ja3MpIHtcbiAgICAgICAgaWYgKFwidHlwZVwiIGluIGJsb2NrICYmIGJsb2NrLnR5cGUgPT09IFwibnVtYmVyZWRfbGlzdF9pdGVtXCIpIHtcbiAgICAgICAgICAgIC8vIGFkZCBudW1iZXJzXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBibG9jay5udW1iZXJlZF9saXN0X2l0ZW0ubnVtYmVyID0gKytudW1iZXJlZExpc3RJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG51bWJlcmVkTGlzdEluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnRzLm1vZGlmeU51bWJlcmVkTGlzdE9iamVjdCA9IG1vZGlmeU51bWJlcmVkTGlzdE9iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/notion-to-md/build/utils/notion.js\n");

/***/ })

};
;